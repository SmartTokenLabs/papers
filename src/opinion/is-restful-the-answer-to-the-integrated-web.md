# Is RESTful the answer to the Integrated Web?

In the early days of my work on Smart Layer, a decentralized protocol for the next web, I was often asked: "Don't web servers already provide integration? Isn't that the purpose of RESTful API?"

The short answer is no. RESTful or even GraphQL are only part of the solution for an integrated web. The long answer, however, takes us back to my university days.

Twenty year ago, our lab in the Uni was commissioned to develop a web system for the Chinese army. The project was primarily managed by research students adept in data management. They crafted the front-end JScript to directly generate SQL statements. These statements were then sanity-checked by the website's unlicensed IIS running ASP code before being dispatched to an unlicensed Microsoft SQL server (a pirated Microsoft stack was, and perhaps still is, popular among the Chinese army).

In one of the meetings, I proposed a web service layer. This layer would take data inquiries from the website, which would not contain any SQL table references, and focus solely on the data needed to render the UI. The web service layer would then generate the underlying SQL statement. 

This suggestion was met with resistance. After all, SQL was invented as a data query language, and the website front end was doing precisely that - querying data. A pass-through ASP page is simple to develop, and front end code directly facing SQL database matches the KISS principle (Keep It Simple and Stupid). However, my proposal aimed at the Separation of Concerns. I argued that a database is architected to do different things than a web service. It's generally good practice to separate an application into different layers, each with its own responsibilities. This approach has numerous benefits. Front-end code won't be affected by database refactoring and is only concerned with user interactions. The server backend can optimise data handling, carry out business logic before sending data to the SQL database, and safeguard against security threats such as DDoS or SQL injection.

My suggestions fell on deaf ears. The project went ahead without any changes. The rationale was that the system was supposed to run in a military network, so there shouldn't be a source for DDoS or SQL Injection attacks - a face-palm-worthy assumption, but try arguing with a Chinese military leader. And inflexibility of handling change is not a problem either - new requirements were usually handled by creating new software from scratch anyway. This was thanks to a reward system by the Communist Party leadership, which favoured shiny new toys over polishing the old ones.

Our software, however, was as useful as a chocolate teapot - it was a medalware, built to strut its stuff in a competition and win a shiny medal for the army branch. The military leader's genius was as clear as day - he didn't dismiss the DDoS or SQL Injection attack thanks to a flawed security model, but because he had an award-winning strategy to win an award in the competition and level up his rank. No real use, no real threats. He just didn't say it at the outset because it wasn't the right thing to say.

Why do I tell the story? This experience serves as a reminder that the format of data exchange - data query with SQL or RESTful API - is not a direct answer to a system problem. Unless it's a medalware system of course - most blockchain ICO software are also medalware, just replacing Communist Party Leadership with gullible retail investors. Let's shift our focus to the real problem Smart Layer aims to solve: the Integrated Web, and observe a similar mismatch between needs and solutions.

Integration is a challenging problem. Just ask any architect of major websites or companies with numerous business connections. It's logical to separate integration into a distinct layer, as they are difficult to move, prone to breaking, require specific incentives to progress, often don't work, and frequently come under scrutiny. Most of these problems that make integration difficult are not due to the lack of a technical interface standard, such as RESTful API - and to be honest it was already used in companies with serious unmet integration needs. This situation parallels how SQL is not the answer to data inquiry for the web front-end. Other concerns, not the ease of use or syntax, influenced the decision to build a middle layer. Today many people still consider SQL not the query language of the web due to its syntax being outlandish to web developers. It's not. Even if the web system prefers to use SQL as a syntax format over JSON, a SQL database still can't replace a web service layer. Similarly, the motivation to build a smart layer to solve integration is not driven by the lack of an API interface.

There is no satisfying Internet integration framework barring "integrate everything to Google/Apple and hope they offer the kinds of integration we need one day".

[The other half of the article is not written yet. It will be about where Smart Layer comes in. It's a separate layer that handles the hard parts of integration, making it easier for websites and apps to work together. It's not about replacing RESTful or GraphQL, but about providing a more robust and flexible infrastructure for the next generation web. And who knows, maybe one day it will even find its way into the Chinese army's web systems.]
